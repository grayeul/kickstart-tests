#!/usr/bin/python3
#
# Copyright (C) 2023  Red Hat, Inc.
#
# This copyrighted material is made available to anyone wishing to use,
# modify, copy, or redistribute it subject to the terms and conditions of
# the GNU General Public License v.2, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY expressed or implied, including the implied warranties of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.  You should have received a copy of the
# GNU General Public License along with this program; if not, write to the
# Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.  Any Red Hat trademarks that are incorporated in the
# source code or documentation are not subject to the GNU General Public
# License and may only be used or replicated with the express permission of
# Red Hat, Inc.

import argparse
import subprocess
import sys
import re
import yaml
import os


FILTER_FILENAMES = ["kstest.log", "virt-install.log"]


def _print_result(issue, matches):
    result = """
-------------------------------------------------------------------------------
{}
#: {}
{}""".format(issue["description"], len(matches), "--\n".join(matches))
    print(result.strip())


def _find_files(args, filenames):
    files = []

    # example: find . -type f \( -name virt-install.log -o -name kstest.log \) -not -path *logs-rhel* -not -path *logs-rhel9*
    filenames_args = []
    if filenames:
        filenames_args = ["("] + [option for value in zip(["-o"] * len(filenames), ["-name"] * len(filenames), filenames) for option in value ][1:] + [")"]
    exclude_dir_args = [option for value in zip(["-not"] * len(args.exclude_dir), ["-path"] * len(args.exclude_dir), ["*{}*".format(dir) for dir in args.exclude_dir]) for option in value ]

    find = subprocess.run(
        [
            "find",
            ".",
            "-type",
            "f",
        ] + filenames_args + exclude_dir_args,
        capture_output=True,
        check=False,
        encoding="utf8",
    )
    if find.stdout:
        files = find.stdout.split()

    return files


def _get_match(issue, file_path, args):
    match = ""

    if "first_grep" in issue:
        grep = subprocess.run(
            [
                "grep",
                "-m", "1",
                issue["first_grep"],
                "-C", str(args.show_line_context),
            ] + [file_path],
            capture_output=True,
            check=False,
            encoding="utf8"
        )
        match = grep.stdout

    if "last_matching_re" in issue:
        last_matching_re = issue["last_matching_re"]
        try:
            line_match_re, line_check_re = last_matching_re[0], last_matching_re[1]
        except (IndexError, TypeError) as e:
            raise ValueError(f"unexpected structure of 'last_matching_re' data: {last_matching_re}: {e}") from e
        last_matching_line = subprocess.check_output(
            "grep {} {} | tail -n 1".format(line_match_re, file_path),
            shell=True,
            encoding="utf8",
        )
        if last_matching_line:
            if re.match(line_check_re, last_matching_line):
                match = last_matching_line

    return match


def load_issues_from_yaml(patterns_file=None):

    if patterns_file:
        yaml_file = patterns_file
    else:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        yaml_file = os.path.join(script_dir, "classify-failures.yml")

    with open(yaml_file, 'r') as f:
        data = yaml.safe_load(f)
    return data.get('issues', [])


def classify(args, filenames):

    file_paths = _find_files(args, filenames)

    issues = load_issues_from_yaml(args.patterns_file)

    for issue in issues:
        if args.filter_issue_contains not in issue["description"]:
            continue

        matches = []

        for file_path in file_paths:
            match = _get_match(issue, file_path, args)
            if match:
                matches.append("{}\n{}".format(file_path, match))

        if matches:
            _print_result(issue, matches)


def cmd_cli():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""
Classify kickstart test failures looked up in logs.

Runs grep in the working directory recursively trying to match log files
to the issues tracked in kickstart-test repository.

Ideally should be run on log files tree produced by weekly_summary script
with --archive-logs option, which is also run by kickstart-test repository
Weekly summary workflow.

Can be used also on any kickstart test logs (the names of files to be
scanned are configurable by option) but examining logs of tests that
passed can produce noise in some cases.""",
        epilog="""
EXAMPLES:

  Look only for issue "[1]" and show context of 3 lines for each match:
  {filename} --show-line-context 3 --filter-issue-contains [1]

  Look only for failures (ignore flakes subdir in log path):
  (Assumes log directory structure produced by weekly_report.)
  {filename} --exclude-dir flakes

  Look only to results of daily-iso scenario:
  (Assumes log directory structure produced by weekly_report.)
  {filename} --exclude-dir "logs-rhel*"
""".format(filename=sys.argv[0])
    )
    parser.add_argument("-p", "--patterns-file",
                        help="YAML file containing issue patterns (default: scripts/classify-failures.yml)",
                        metavar="FILE", default=None)
    parser.add_argument("-i", "--filter-issue-contains",
                        help="only look for issues containing this substring",
                        metavar="STRING", default="")
    parser.add_argument("-f", "--filter-filenames",
                        help="only look at specified log files",
                        metavar="FILENAME", nargs="?", action='append', default=[])
    parser.add_argument("-d", "--exclude-dir",
                        help="exclude directories with suffix (grep API)",
                        metavar="GLOB", nargs="?", action='append', default=[])
    parser.add_argument("-c", "--show-line-context",
                        help="show context of the found string",
                        metavar="N", default=0, type=int)
    args = parser.parse_args()

    filenames = args.filter_filenames or FILTER_FILENAMES

    try:
        classify(args, filenames)
    except FileNotFoundError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except yaml.YAMLError as e:
        print(f"Error parsing patterns file: {e}", file=sys.stderr)
        sys.exit(1)
    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    cmd_cli()
